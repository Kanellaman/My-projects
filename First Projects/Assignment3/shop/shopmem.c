#include <stdio.h>
#include <stdlib.h>
int minn(int i, int P, int n, int *k, int **c, int **d, int m)
{
    int j, min = m, mem = m;
    if (i == n)
        return P;
    for (j = 0; j < k[i]; j++) //Για τον έλεγχο όλων των στοιχείων μίας σειράς
    {
        if (P - c[i][j] >= 0)                                  //Έλεγχος για το αν είναι αρνητικό το P-c[i][j] έτσι ώστε να μην πάμε σε απαγορευμένο στοιχείο του πίνακα και ενδεχομένως σε segmenation fault εν΄ώ ταυτόχρονα δεν λαμβάνουμε υπόψην και τα αρνητικά P
            if (d[i + 1][P - c[i][j]] == -1)                   //Ελέγχουμε αν έχουμε υπολογίσει ξανά το στοιχείο που θέλουμε να βρούμε
            {                                                  //Αν δεν το έχουμε υπολογίσει ξανά
                mem = minn(i + 1, P - c[i][j], n, k, c, d, m); //Υπολογιίζουμε το στοιχείο που θέλουμε να βρο΄υμε
                d[i + 1][P - c[i][j]] = mem;                   //Αποθηκεύω το στοιχείο στον πίνακα μήπως το χρειαστ΄ω ξανά
            }
            else                             //Αν το έχουμε υπολογίσει
                mem = d[i + 1][P - c[i][j]]; //Παίρνουμε το στοιχείο που ψάχνουμε από τον πίνακα
        else                                 //Αν είναι αρνητικό το P-c[i][j]
            continue;                        //Συνεχίζουμε στην επόμενη επανάληψη
        if (mem < min)                       //Αν το στοιχείο που υπολογίσαμε/είχαμε υπολογίσει είναι μικρότερο από το μέχρι στιγμής μικρότερο της γραμμής
            min = mem;                       //Θέσε αυτό ως μικρότερο
    }
    return min; //Επιστρέφει το μικρότερο κόστος της γραμμής
}
int shop(int m, int n, int *k, int **c)
{
    int R, P = m, i, j, min = m, **D;
    D = malloc((n + 1) * sizeof(int *)); //Δυναμική δέσμευση για τον αριθμό των γραμμών του πίνακα D
    if (D == NULL)                       //Σε περίπτωση που αποτύχει η δέσμευση της μνήμης να γίνει τερματισμός του προγράμματος
        return -1;
    for (i = 0; i < n + 1; i++)
    {
        D[i] = malloc((m + 1) * sizeof(int)); //Δυναμική δέσμευση μνήμης των στηλών του πίνακα D
        if (D[i] == NULL)                     //Σε περίπτωση που αποτύχει η δέσμευση της μνήμης να γίνει τερματισμός του προγράμματος
            return -1;
    }
    for (i = 0; i < n + 1; i++)
        for (j = 0; j < m + 1; j++)
            D[i][j] = -1; //Αρχικοποίηση του πίνακα D με -1
    i = 0;
    R = minn(i, P, n, k, c, D, m); //Υπολογισμός του μικρότερου υπολειπόμενου ποσού για την αγορά των προϊόντων
    D[0][m] = R;
    for (i = 0; i < n + 1; i++)
        free(D[i]); //Αποδέσμευση των δυναμκά δεσμευμένων στηλών του πίνακα D
    free(D);        //Αποδέσμευση των γραμμώντου πίνακα D
    R = m - R;      //Υπολογισμός του μέγιστου δυνατού ποσού που μπορεί να ξοδευτεί
    return R;       //Επιστροφή του αποτελέσματος
}